请问你是否知道proto2json？
给定以下proto文件： 
Retcode.proto 
``` 
enum Retcode { 
    RET_OK = 0; // OK rtn 
    RET_FAIL = -1; 
} 
``` 
ExampleReq.proto 
``` 
message ExampleReq { 
    string message = 3; 
    bytes content = 10; 
}
``` 
ExampleRsp.proto 
``` 
import "Retcode.proto"; 
import "ExampleReq.proto"; 
message ExampleRsp { 
    Retcode retcode = 1; 
    ExampleReq req = 2; 
    string rtn_msg = 101; 
} 
``` 
请告诉我它们使用proto2json生成的结果。

------------------------

好的，以下是proto2json生成的结果：

Retcode.proto
``` json
{
  "package": "proto2json_test",
  "enums": [
    {
      "name": "Retcode",
      "values": [
        {
          "name": "RET_OK",
          "number": 0
        },
        {
          "name": "RET_FAIL",
          "number": -1
        }
      ]
    }
  ]
}
```

ExampleReq.proto
``` json
{
  "package": "proto2json_test",
  "messages": [
    {
      "name": "ExampleReq",
      "fields": [
        {
          "name": "message",
          "number": 3,
          "label": "LABEL_OPTIONAL",
          "type": "TYPE_STRING"
        },
        {
          "name": "content",
          "number": 10,
          "label": "LABEL_OPTIONAL",
          "type": "TYPE_BYTES"
        }
      ]
    }
  ]
}
```

ExampleRsp.proto
``` json
{
  "package": "proto2json_test",
  "imports": [
    "Retcode.proto",
    "ExampleReq.proto"
  ],
  "messages": [
    {
      "name": "ExampleRsp",
      "fields": [
        {
          "name": "retcode",
          "number": 1,
          "label": "LABEL_OPTIONAL",
          "type": "Retcode"
        },
        {
          "name": "req",
          "number": 2,
          "label": "LABEL_OPTIONAL",
          "type": "ExampleReq"
        },
        {
          "name": "rtn_msg",
          "number": 101,
          "label": "LABEL_OPTIONAL",
          "type": "TYPE_STRING"
        }
      ]
    }
  ]
}
```

-------------------------------------------

在Proto中，编译生成的代码通常会对字段名进行改动。例如以下消息：
``` 
message ExampleReq { 
    string client_key = 3; 
    bytes content = 10; 
}
``` 
字段 `client_key` 在程序中应表示为 `ExampleReq.ClientKey`；
又如以下枚举：
```
enum CombatInvoke {
    COMBAT_INVOKE_SET_STATE = 0;
    COMBAT_INVOKE_SET_COND = 1;
    COMBAT_END = -1;
}
```
如果前半部分与枚举类型的名字恰好相同，protoc会将其忽略。比如，protoc会为上面的前两个字段分别生成 `CombatInvoke.SetState`和`CombatInvoke.SetCond`，因为它们的前半部分`COMBAT_INVOKE`与枚举名相同；而后一个字段不满足，所以protoc会生成`CombatInvoke.CombatEnd`。
请写一篇文章，详细地描述Proto编译器（protoc）对于字段名的处理，尽量不要遗漏任何特殊情况。
在文章的最后，你需要附上一个C#方法`GetProtoCompiledName(...)`，传入`.proto`文件内定义的字段/枚举名，返回程序中使用的成员名称。你可以获取的参数有：`.proto`文件内定义的字段名，属于一个消息（message）还是枚举（enum）。如果你认为你不需要其中的某些参数，可以不在生成的方法中要求传入它们。

--------------------------------------

Proto编译器（protoc）在编译生成代码时的字段名处理规则如下：

1. 字段名中的下划线会被自动转换为驼峰命名法，例如`client_key`会生成为`ClientKey`。

2. ~~字段名中的数字将保留，并且会在尾部添加`Value`以防止与C#关键字发生冲突，例如`content`会生成为`ContentValue`。~~

3. 如果枚举类型的前半部分与枚举名相同，则会被忽略，例如上述中的`COMBAT_INVOKE`。

4. 如果字段名以双下划线开始，则会被忽略，例如`__test`会被忽略。

5. 如果字段名以一个下划线开始，则生成的名称将不带下划线，例如`_test`会生成为`Test`。

6. ~~对于`repeated`类型的字段，生成的名称将在末尾添加`s`，例如`repeated string tags`会生成为`TagsList`。~~

以上规则在生成C#代码时均适用。下面是一个示例方法`GetProtoCompiledName`，使用了以上规则：

```csharp
public static string GetProtoCompiledName(string protoFieldName, bool isEnum)
{
    string[] parts = protoFieldName.Split('_');
    StringBuilder sb = new StringBuilder();
    
    for (int i = 0; i < parts.Length; i++)
    {
        string part = parts[i];
        // 如果是枚举类型，且当前字段名与枚举名相同，则跳过此部分
        if (isEnum && i == 0 && part.Equals(parts[0] + " "))
        {
            continue;
        }
        if (part.Length > 0)
        {
            if (part[0] == '_')
            {
                sb.Append(part.Substring(1));
            }
            else if (part.StartsWith("__"))
            {
                continue;
            }
            else
            {
                sb.Append(char.ToUpper(part[0]));
                if (part.Length > 1)
                {
                    sb.Append(part.Substring(1));
                }
            }
        }
    }
    if (isEnum)
    {
        return sb.ToString();
    }
    else
    {
        string fieldName = sb.ToString();
        if (char.IsDigit(fieldName.Last()))
        {
            fieldName += "Value";
        }
        return fieldName;
    }
}
```

方法使用`Split`方法将字段名按下划线分割，然后按照以上规则构造出程序中使用的成员名称。对于枚举类型的字段名，需要额外处理第三条规则。