// See https://aka.ms/new-console-template for more information
using System.Collections.Concurrent;
using System.Diagnostics;
using ProtobufRegen;
using ProtobufRegen.RegenOutput;
using YYHEggEgg.Logger;

StartupWorkingDirChanger.ChangeToDotNetRunPath(new LoggerConfig(
    max_Output_Char_Count: 16 * 1024,
    use_Console_Wrapper: false,
    use_Working_Directory: true,
#if DEBUG
    global_Minimum_LogLevel: LogLevel.Verbose,
    console_Minimum_LogLevel: LogLevel.Information,
#else
    global_Minimum_LogLevel: LogLevel.Information,
    console_Minimum_LogLevel: LogLevel.Information,
#endif
    debug_LogWriter_AutoFlush: false,
    is_PipeSeparated_Format: false,
    enable_Detailed_Time: false
));

Log.Info($"请将所需的前缀置于 pre_license.txt.");

Log.Info($"请输入 protobuf 路径：");
string path = Console.ReadLine();

Log.Info($"复制文件到 ./GenProtos ...");
Directory.CreateDirectory("./GenProtos");
CopyDir(path, "./GenProtos");

string workingdir = Environment.CurrentDirectory;
DirectoryInfo _workingdirinfo = new(workingdir);
string proto2jsondir = $"{workingdir}/proto2json";
if (!File.Exists($"{proto2jsondir}/go-proto2json_win32.exe"))
{
    Log.Erro("Proto2json not found! Please make sure you're running program with dotnet run and have comiled Executable!", "ResourcesCheck");

    Log.Erro("Process terminated for protos/proto2json executable lost. Exit code is 272574.", "ResourcesCheck");
    Console.ReadLine();
    Environment.Exit(272574);
}
#region Invoke proto2json
if (Directory.Exists($"{workingdir}/Proto2json_Output"))
{
    Log.Info("Detected old output directory, deleting...");
    Directory.Delete($"{workingdir}/Proto2json_Output", true);
}
Log.Info("Start invoking proto2json.exe. Please wait patiently...", "OuterInvoke");
Stopwatch pinvokewatch = Stopwatch.StartNew();
#region Split OS
// Generated by Cursor
// Fuck Cursor
string proto2json_invokestr = "";
string arch = Environment.Is64BitOperatingSystem ? "64" : "32";
#region Windows
if (OperatingSystem.IsWindows())
{
    Log.Dbug($"Found OS Type: Windows x{arch}.", "OuterInvoke");
    proto2json_invokestr = $"{proto2jsondir}/go-proto2json_win{arch}.exe";
}
#endregion
#region macOS
else if (OperatingSystem.IsMacOS())
{
    Log.Dbug($"Found OS Type: macOS x{arch}.", "OuterInvoke");
    Log.Dbug($"Assigning chmod +x...");
    proto2json_invokestr = $"{proto2jsondir}/go-proto2json_mac{arch}";
    await OuterInvoke.Run(new OuterInvokeInfo
    {
        ProcessPath = "chmod",
        CmdLine = $"+x {proto2json_invokestr}"
    });
}
#endregion
#region Linux
else if (OperatingSystem.IsLinux())
{
    Log.Dbug($"Found OS Type: Linux x{arch}.", "OuterInvoke");
    Log.Dbug($"Assigning chmod +x...");
    proto2json_invokestr = $"{proto2jsondir}/go-proto2json_linux{arch}";
    await OuterInvoke.Run(new OuterInvokeInfo
    {
        ProcessPath = "chmod",
        CmdLine = $"+x {proto2json_invokestr}"
    });
}
#endregion
else
{
    Log.Erro($"Unsupported OS detected! OS: {Environment.OSVersion.Platform} x{arch}. Please report this to Issues of this project.", "OuterInvoke");
    Log.Erro("Process terminated for unsupported OS. Exit code is 100.", "OuterInvoke");
    Console.ReadLine();
    Environment.Exit(100);
}
#endregion
Log.Dbug($"Using proto2json at path {proto2jsondir}.");
await OuterInvoke.Run(new OuterInvokeInfo
{
    ProcessPath = proto2json_invokestr,
    AutoTerminateReason = "Process terminated for proto2json not working properly.",
    WorkingDir = proto2jsondir
}, 3300);
pinvokewatch.Stop();
Log.Info($"proto2json exited. Total execute time is {pinvokewatch.Elapsed}.", "OuterInvoke");
#endregion

string pre_license = File.ReadAllText("pre_license.txt");

Log.Info($"参数解析完成。结果将会生成在 'regen-res' 文件夹中。");

var protojsons = Directory.EnumerateFiles("./Proto2json_Output");
Directory.CreateDirectory("regen-res");
Parallel.ForEach(protojsons, path =>
{
    ProtoJsonResult analyzeResult = JsonAnalyzer.AnalyzeProtoJson(File.ReadAllText(path));
    foreach (var message in analyzeResult.messageBodys)
    {
        BasicCodeWriter fi = PreGenerate($"{message.messageName}.proto");
        SortedSet<string> imports = new();
        RegenOutputMessage.OutputMessage(ref fi, ref imports, message);
        fi.WriteLine();
        foreach (var importfile in imports)
        {
            fi.WriteLine($"import \"{importfile}.proto\";");
        }
        fi.WriteLine();
        fi.Dispose();
    }
    foreach (var enumResult in analyzeResult.enumBodys)
    {
        BasicCodeWriter fi = PreGenerate($"{enumResult.enumName}.proto");
        RegenOutputEnum.OutputEnum(ref fi, enumResult);
        fi.Dispose();
    }
});

Log.Info($"生成成功！按 Enter 退出。");

BasicCodeWriter PreGenerate(string fileName)
{
    BasicCodeWriter fi = new($"regen-res/{fileName}");
    fi.WriteLine(pre_license);
    fi.WriteLine();
    fi.WriteLine("syntax = \"proto3\";");
    fi.WriteLine();
    fi.WriteLine("package MiHomo.Protos; // 占位符，请替换");
    fi.WriteLine();
    return fi;
}



void CopyDir(string source, string target)
    => CopyFilesRecursively(Path.GetFullPath(source), Path.GetFullPath(target));

// .net - Copy the entire contents of a directory in C#
// https://stackoverflow.com/questions/58744/copy-the-entire-contents-of-a-directory-in-c-sharp
void CopyFilesRecursively(string sourcePath, string targetPath)
{
    //Now Create all of the directories
    foreach (string dirPath in Directory.GetDirectories(sourcePath, "*", SearchOption.AllDirectories))
    {
        Directory.CreateDirectory(dirPath.Replace(sourcePath, targetPath));
    }

    //Copy all the files & Replaces any files with the same name
    foreach (string newPath in Directory.GetFiles(sourcePath, "*.*", SearchOption.AllDirectories))
    {
        File.Copy(newPath, newPath.Replace(sourcePath, targetPath), true);
    }
}