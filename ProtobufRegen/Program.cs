// See https://aka.ms/new-console-template for more information
using System.Collections.Concurrent;
using System.Diagnostics;
using ProtobufRegen;
using ProtobufRegen.RegenOutput;
using YYHEggEgg.Logger;

StartupWorkingDirChanger.ChangeToDotNetRunPath(new LoggerConfig(
    max_Output_Char_Count: 16 * 1024,
    use_Console_Wrapper: false,
    use_Working_Directory: true,
#if DEBUG
    global_Minimum_LogLevel: LogLevel.Verbose,
    console_Minimum_LogLevel: LogLevel.Information,
#else
    global_Minimum_LogLevel: LogLevel.Information,
    console_Minimum_LogLevel: LogLevel.Information,
#endif
    debug_LogWriter_AutoFlush: false,
    is_PipeSeparated_Format: false,
    enable_Detailed_Time: false
));

Log.Info($"请将所需的前缀置于 pre_license.txt.");

Log.Info($"请输入 protobuf 路径：");
#if FORBID_ENUM_CMDID
Log.Warn($"本次生成将剥离 Proto/CmdId 枚举；可在 .csproj 中取消 FORBID_ENUM_CMDID 并重新生成来取消。");
#endif
string path = Console.ReadLine();

Log.Info("请输入输出存放路径（其内容将被完全覆盖）：");
string outputpath = Console.ReadLine();

Log.Info($"复制文件到 ./GenProtos ...");
try { Directory.Delete("./GenProtos", true); } catch {  }
CopyDir(path, "./GenProtos");

string workingdir = Environment.CurrentDirectory;
DirectoryInfo _workingdirinfo = new(workingdir);
string proto2jsondir = $"{workingdir}/proto2json";
if (!File.Exists($"{proto2jsondir}/go-proto2json_win32.exe"))
{
    Log.Erro("Proto2json not found! Please make sure you're running program with dotnet run and have comiled Executable!", "ResourcesCheck");

    Log.Erro("Process terminated for protos/proto2json executable lost. Exit code is 272574.", "ResourcesCheck");
    Console.ReadLine();
    Environment.Exit(272574);
}
#region Invoke proto2json
if (Directory.Exists($"{workingdir}/Proto2json_Output"))
{
    Log.Info("Detected old output directory, deleting...");
    Directory.Delete($"{workingdir}/Proto2json_Output", true);
}
Log.Info("Start invoking proto2json.exe. Please wait patiently...", "OuterInvoke");
Stopwatch pinvokewatch = Stopwatch.StartNew();
#region Split OS
// Generated by Cursor
// Fuck Cursor
string proto2json_invokestr = "";
string arch = Environment.Is64BitOperatingSystem ? "64" : "32";
#region Windows
if (OperatingSystem.IsWindows())
{
    Log.Dbug($"Found OS Type: Windows x{arch}.", "OuterInvoke");
    proto2json_invokestr = $"{proto2jsondir}/go-proto2json_win{arch}.exe";
}
#endregion
#region macOS
else if (OperatingSystem.IsMacOS())
{
    Log.Dbug($"Found OS Type: macOS x{arch}.", "OuterInvoke");
    Log.Dbug($"Assigning chmod +x...");
    proto2json_invokestr = $"{proto2jsondir}/go-proto2json_mac{arch}";
    await OuterInvoke.Run(new OuterInvokeInfo
    {
        ProcessPath = "chmod",
        CmdLine = $"+x {proto2json_invokestr}"
    });
}
#endregion
#region Linux
else if (OperatingSystem.IsLinux())
{
    Log.Dbug($"Found OS Type: Linux x{arch}.", "OuterInvoke");
    Log.Dbug($"Assigning chmod +x...");
    proto2json_invokestr = $"{proto2jsondir}/go-proto2json_linux{arch}";
    await OuterInvoke.Run(new OuterInvokeInfo
    {
        ProcessPath = "chmod",
        CmdLine = $"+x {proto2json_invokestr}"
    });
}
#endregion
else
{
    Log.Erro($"Unsupported OS detected! OS: {Environment.OSVersion.Platform} x{arch}. Please report this to Issues of this project.", "OuterInvoke");
    Log.Erro("Process terminated for unsupported OS. Exit code is 100.", "OuterInvoke");
    Console.ReadLine();
    Environment.Exit(100);
}
#endregion
Log.Dbug($"Using proto2json at path {proto2jsondir}.");
await OuterInvoke.Run(new OuterInvokeInfo
{
    ProcessPath = proto2json_invokestr,
    AutoTerminateReason = "Process terminated for proto2json not working properly.",
    WorkingDir = proto2jsondir
}, 3300);
pinvokewatch.Stop();
Log.Info($"proto2json exited. Total execute time is {pinvokewatch.Elapsed}.", "OuterInvoke");
#endregion

string pre_license = File.ReadAllText("pre_license.txt");

Log.Info($"参数解析完成。结果将会生成在 '{outputpath}' 文件夹中。");
try { Directory.Delete(outputpath, true); } catch {  }

var protojsons = Directory.EnumerateFiles("./Proto2json_Output");
Directory.CreateDirectory(outputpath);
ConcurrentDictionary<string, int> cmdidlist = new();
Parallel.ForEach(protojsons, path =>
{
    ProtoJsonResult analyzeResult = JsonAnalyzer.AnalyzeProtoJson(File.ReadAllText(path));
    foreach (var message in analyzeResult.messageBodys)
    {
        BasicCodeWriter fi = PreGenerate(outputpath, $"{message.messageName}.proto");
        SortedSet<string> imports = new();
        RegenOutputMessage.OutputMessage(ref fi, ref imports, message);
        var external_imports = from importorigin in imports
                               let nestedIdentifier = importorigin.IndexOf('.')
                               let importfile = (nestedIdentifier < 0) 
                                   ? importorigin 
                                   : importorigin.Substring(0, nestedIdentifier)
                               where importfile != message.messageName
                               where !message.messageFields.Any(field => field.messageName == importfile)
                               where !message.enumFields.Any(field => field.enumName == importfile)
                               orderby importfile
                               select importfile;
        if (external_imports.Any()) fi.WriteLine();
        foreach (var importfile in external_imports)
        {
            fi.WriteLine($"import \"{importfile}.proto\";");
        }
        fi.Dispose();
        var cmdidenum = message.enumFields.Find(enumResult => enumResult.enumName == "CmdId");
        if (cmdidenum != null) 
        {
            var cmdid_tuple = cmdidenum.enumNodes.Find(enumNodeTuple => enumNodeTuple.name == "CMD_ID");
            if (cmdid_tuple.name == "CMD_ID") cmdidlist.TryAdd(message.messageName, cmdid_tuple.number);
        }
    }
    foreach (var enumResult in analyzeResult.enumBodys)
    {
        BasicCodeWriter fi = PreGenerate(outputpath, $"{enumResult.enumName}.proto");
        RegenOutputEnum.OutputEnum(ref fi, enumResult);
        fi.Dispose();
    }
});

Log.Info($"protobuf 解析生成完毕。正在导出 CMD_ID 至 cmdid.csv...");
var lines = from pair in cmdidlist
            orderby pair.Key
            select $"{pair.Key},{pair.Value}";
File.WriteAllLines(Path.Combine(outputpath, "cmdid.csv"), lines);

Log.Info($"生成成功！");

BasicCodeWriter PreGenerate(string basedir, string fileName)
{
    BasicCodeWriter fi = new(Path.Combine(basedir, fileName));
    fi.WriteLine(pre_license);
    fi.WriteLine();
    fi.WriteLine("syntax = \"proto3\";");
    fi.WriteLine();
    fi.WriteLine("package miHomo.Protos;");
    fi.WriteLine();
    return fi;
}

void CopyDir(string source, string target)
{
    Directory.CreateDirectory(target);
    CopyFilesRecursively(Path.GetFullPath(source), Path.GetFullPath(target));
}

// .net - Copy the entire contents of a directory in C#
// https://stackoverflow.com/questions/58744/copy-the-entire-contents-of-a-directory-in-c-sharp
void CopyFilesRecursively(string sourcePath, string targetPath)
{
    //Now Create all of the directories
    foreach (string dirPath in Directory.GetDirectories(sourcePath, "*", SearchOption.AllDirectories))
    {
        Directory.CreateDirectory(dirPath.Replace(sourcePath, targetPath));
    }

    //Copy all the files & Replaces any files with the same name
    foreach (string newPath in Directory.GetFiles(sourcePath, "*.*", SearchOption.AllDirectories))
    {
        File.Copy(newPath, newPath.Replace(sourcePath, targetPath), true);
    }
}